<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube with SRT Subtitles</title>
    <link href="https://fonts.googleapis.com/css2?family=Iansui&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            min-height: 100vh;
            padding-bottom: 40px;
        }
        #video-container {
            position: relative;
            width: 100vw;
            height: calc(100vw * 9 / 16);
            max-height: 80vh;
            background-color: #000; /* Added background for when video isn't loaded */
        }
        #player {
            width: 100%;
            height: 100%;
        }
        #subtitle {
            font-size: 24px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            width: 80%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 5px;
            font-family: 'Iansui', sans-serif;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            min-height: 1.5em; /* Ensure space even when empty */
            box-sizing: border-box;
        }
        /* New style for base subtitle name */
        #baseSubtitleNameDisplay {
            font-size: 20px; /* Slightly smaller than subtitle */
            text-align: center;
            color: #444; /* Less prominent color */
            padding: 5px 10px;
            width: 80%;
            max-width: 640px;
            margin: 8px auto 0 auto; /* Margin top to space from video */
            font-family: 'Iansui', sans-serif; /* Same font as subtitle */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: none; /* Hidden by default */
        }

        #controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 640px;
            padding: 0 10px;
            box-sizing: border-box;
        }
        .input-group, .srt-group, .url-group, .loaded-subtitle-group { /* Added loaded-subtitle-group */
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }
        input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 5px;
            flex-grow: 1;
            min-width: 200px;
            max-width: 300px;
            outline: none;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        input[type="text"]:focus {
            border-color: #007bff;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 140px;
            box-sizing: border-box; /* Ensure padding doesn't increase size */
            flex-shrink: 0; /* Prevent buttons from shrinking too much */
        }
        button:hover {
            background-color: #0056b3;
        }
        #srtFile {
            display: none;
        }
        .custom-file-button, .url-upload-button, #downloadSubtitleButton { /* Added download button */
            padding: 10px 20px;
            font-size: 16px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 140px;
        }
        .custom-file-button:hover, .url-upload-button:hover, #downloadSubtitleButton:hover { /* Added download button hover */
            background-color: #218838;
        }
        #downloadSubtitleButton { /* Specific style for download button */
             background-color: #17a2b8; /* Different color */
             width: auto; /* Auto width based on content */
             padding: 10px 15px; /* Slightly less padding */
             display: none; /* Hidden by default */
             min-width: 140px; /* Maintain minimum width */
        }
        #downloadSubtitleButton:hover {
             background-color: #138496;
        }

        #srtFileName { /* Original status display */
            padding: 10px;
            font-size: 16px;
            color: #333;
            border: 2px solid #ccc;
            border-radius: 5px;
            flex-grow: 1;
            min-width: 200px;
            max-width: 300px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            box-sizing: border-box;
            height: 40px;
            line-height: 20px;
            background-color: #eee;
        }

        /* --- Styles for Embedded URL Section --- */
        #embeddedUrlContainer {
            margin-top: 10px; /* Reduced margin */
            width: 100%;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: stretch;
            box-sizing: border-box;
        }
        #embeddedUrlTitleContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        #embeddedUrlTitle {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        #copyUrlButton {
            padding: 5px 10px;
            font-size: 14px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            width: auto;
            min-width: 60px;
        }
        #copyUrlButton:hover {
            background-color: #5a6268;
        }
        #copyUrlButton:active {
             background-color: #4e555b;
        }
        #copyUrlButton.copied {
            background-color: #28a745;
        }
        #embeddedUrlTextarea {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f9fa;
            color: #333;
            resize: none;
            box-sizing: border-box;
            min-height: 60px;
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-all;
             -webkit-user-select: none;
             -moz-user-select: none;
              -ms-user-select: none;
                  user-select: none;
             cursor: default;
        }

        /* New container for loaded subtitle info */
        #loadedSubtitleInfoContainer {
            margin-top: 0px; /* Reduced space needed now it's separate */
            width: 100%;
            padding: 10px 0; /* Add some vertical padding */
            border-radius: 5px;
            display: none; /* Hidden by default */
            flex-direction: column; /* Stack text and button */
            align-items: center; /* Center items */
            gap: 10px; /* Space between text and button */
            box-sizing: border-box;
        }
        #loadedSubtitleFilenameText {
            font-size: 15px;
            color: #333;
            padding: 5px 10px;
            background-color: #f8f9fa;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            overflow-wrap: break-word; /* Wrap long filenames */
            word-break: break-all;
            max-width: 90%; /* Prevent overflow */
            box-sizing: border-box;
        }

        details {
            margin-top: 30px; /* Adjusted margin */
            margin-bottom: 20px;
            padding: 0;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 640px;
            margin-left: auto;
            margin-right: auto;
        }
        details summary {
            padding: 15px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            list-style: none;
            outline: none;
        }
        details summary::-webkit-details-marker {
           display: none;
        }
        details summary::before {
            content: '► ';
            margin-right: 5px;
        }
        details[open] summary::before {
            content: '▼ ';
        }
        #help {
            padding: 0 20px 20px 20px;
            font-size: 14px;
            line-height: 1.5;
            text-align: left;
        }
        #help h3 {
            margin-top: 0;
            font-size: 16px;
        }
        #help pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <div id="player"></div>
        <div id="subtitle"></div> <!-- Subtitle overlay -->
    </div>
    <!-- Base subtitle name display below video -->
    <div id="baseSubtitleNameDisplay"></div>

    <div id="controls">
        <div class="input-group">
            <input type="text" id="youtubeUrl" placeholder="Enter YouTube URL" />
            <button onclick="loadVideo()">Load YT Video</button>
        </div>
        <div class="srt-group">
            <!-- This span now shows general status like "No file selected" or "Loaded from URL" -->
            <span id="srtFileName">No file selected</span>
            <input type="file" id="srtFile" accept=".srt,.txt" />
            <button class="custom-file-button" onclick="document.getElementById('srtFile').click()">Subtitle from Local</button>
        </div>
        <div class="url-group">
            <input type="text" id="subtitleUrl" placeholder="Enter Subtitle URL (.srt or .txt)" />
            <button class="url-upload-button" onclick="loadSubtitleFromUrl()">Subtitle from URL</button>
        </div>
   <!-- Add this inside <div id="controls"> -->
        <div class="input-group" style="margin-top: 20px; border-top: 1px solid #ccc; padding-top: 20px;">
        <button onclick="generateAndCopyLink()" style="width: 250px; background-color: #6f42c1;">Generate & Copy Link</button>
        </div>
        <!-- Embedded URL Section (unchanged structure) -->
        <div id="embeddedUrlContainer">
            <div id="embeddedUrlTitleContainer">
                <span id="embeddedUrlTitle">Embedded URL</span>
                <button id="copyUrlButton">Copy</button>
            </div>
            <textarea id="embeddedUrlTextarea" rows="3" readonly title="Visually readable URL (may not function correctly when copied)"></textarea>
        </div>

        <!-- New section for loaded subtitle details -->
        <div id="loadedSubtitleInfoContainer">
            <span id="loadedSubtitleFilenameText"></span>
            <button id="downloadSubtitleButton" onclick="downloadOriginalSubtitle()">Download Subtitle</button>
        </div>
    </div>

    <details>
        <summary>User Guide and Examples</summary>
        <div id="help">
            <h2>[ YouTube with SRT Subtitles ]</h2>
            <h3>Subtitle format is automatically detected from file extension (.txt or .srt).</h3>
            <h3>The subtitle file can be downloaded, corrected, and re-uploaded by you.</h3>
            <h3>
            <strong>URL for Test</strong>
            <pre>
    Video: https://youtu.be/PTJ8yizhoIY?si=JvaNRX3D1idI84Lu
    .txt subtitle: https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/refs/heads/main/assets/test/PTJ8yizhoIY_transcript.txt
    .srt subtitle: https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/refs/heads/main/assets/test/PTJ8yizhoIY_transcript.srt
            </pre>
            <strong>Embedded URL with URL parameters</strong>
            <pre>
    An embedded URL incorporated with a video URL and subtitle URL will be generated automatically once two URLs are input.

    Format: https://cyberoohim.github.io/pages/youtube_with_srt_subtitles.html?videoUrl={YouTube URL}&subtitleUrl={Subtitle URL}

    Example (showing readable parameters):
    https://cyberoohim.github.io/pages/youtube_with_srt_subtitles.html?videoUrl=https://youtu.be/PTJ8yizhoIY?si=JvaNRX3D1idI84Lu&subtitleUrl=https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/refs/heads/main/assets/test/PTJ8yizhoIY_transcript.srt
            </pre>
            <strong>.txt (with timestamps)</strong>
            <pre>
[0:00] welcome back to the AI Daily Brief every
[0:02] day it feels like a million new cool AI
[0:04] startups launch so much so that it's
[0:07] actually pretty rare that we dig deep
[0:08] and cover brand new companies on this
            </pre>
            <strong>.srt</strong>
            <pre>
1
00:00:00,000 --> 00:00:02,000
welcome back to the AI Daily Brief every

2
00:00:02,000 --> 00:00:04,000
day it feels like a million new cool AI

3
00:00:04,000 --> 00:00:07,000
startups launch so much so that it's

4
00:00:07,000 --> 00:00:08,000
actually pretty rare that we dig deep

5
00:00:08,000 --> 00:00:10,000
and cover brand new companies on this
            </pre>
            </h3>
        </div>
    </details>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        let player;
        let subtitles = [];
        //      --- const BASE_EMBED_URL = "https://cyberoohim.github.io/pages/youtube_with_srt_subtitles.html"; ---
        const BASE_EMBED_URL = "https://hangkapiphang.github.io/taigi/script_test2.html";
        let copyTimeout = null;        
        
        // --- NEW Global State for Original Subtitle Info ---
        let originalSubtitleContent = null;
        let originalSubtitleFilename = null;
        let subtitleSourceType = null; // 'local' or 'url'

        // --- Core Functions (Modified where noted) ---
        function onYouTubeIframeAPIReady() {
            loadFromUrlParams();
        }

        function loadVideo() {
            const url = document.getElementById('youtubeUrl').value.trim();
            if (!url) { alert('Please enter a YouTube URL'); return; }
            const videoId = extractVideoId(url);
            if (!videoId) { alert('Invalid YouTube URL'); return; }

            if (player) {
                player.loadVideoById(videoId);
            } else {
                player = new YT.Player('player', {
                    height: '100%', width: '100%', videoId: videoId,
                    playerVars: { 'playsinline': 1 },
                    events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }
                });
            }
            updateEmbeddedUrlDisplay(); // Update display after loading video
        }

        function extractVideoId(url) {
            let videoId = null;
            const patterns = [
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?.*v=([^&]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([^?]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([^?]+)/
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match && match[1]) { videoId = match[1]; break; }
            }
            // Relaxed validation slightly to allow IDs > 11 chars, though standard is 11
            // if (videoId && /^[a-zA-Z0-9_-]{11,}$/.test(videoId)) { return videoId; }
             if (videoId && videoId.length >= 11) { // Basic check
                // Further refine: Remove potential trailing non-ID chars if pattern was too broad
                videoId = videoId.split('&')[0]; // Common issue
                if (/^[a-zA-Z0-9_-]+$/.test(videoId)) { // Check characters
                     return videoId;
                }
             }
            return null;
        }

        function onPlayerReady(event) { setInterval(updateSubtitles, 100); }
        function onPlayerStateChange(event) { /* Handle if needed */ }

        function parseSRT(srtContent) {
            subtitles = []; // Clear previous parsed subtitles
            const lines = srtContent.replace(/\r/g, '').trim().split('\n\n');
            for (const block of lines) {
                const blockParts = block.split('\n');
                if (blockParts.length >= 3) {
                    const time = blockParts[1];
                    const textLines = blockParts.slice(2);
                    const timeMatch = time.match(/(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})/);
                    if (timeMatch) {
                        const [_, start, end] = timeMatch;
                        subtitles.push({ start: timeToSeconds(start), end: timeToSeconds(end), text: textLines.join(' ').trim() });
                    } else { console.warn("Skipping invalid SRT time format:", time); }
                } else if (block.trim()) { console.warn("Skipping invalid SRT block:", block); }
            }
            console.log(`Parsed ${subtitles.length} subtitle entries.`);
            updateLoadedSubtitleDisplay(); // Update display after successful parsing
            updateBaseSubtitleNameDisplay(); // Update base name display
        }

        function timeToSeconds(time) {
            const parts = time.replace(',', '.').split(':');
            if (parts.length === 3) {
                const [hours, minutes, seconds] = parts;
                return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseFloat(seconds);
            } return 0;
        }

        function updateSubtitles() {
            if (!player || typeof player.getCurrentTime !== 'function' || !subtitles.length) {
                 document.getElementById('subtitle').textContent = ''; return;
            }
            try {
                const currentTime = player.getCurrentTime();
                const currentSubtitle = subtitles.find(s => currentTime >= s.start && currentTime <= s.end);
                document.getElementById('subtitle').textContent = currentSubtitle ? currentSubtitle.text : '';
            } catch (error) {
                // Ignore common error when player is destroyed or not ready
                if (error.message !== "Cannot read properties of null (reading 'getCurrentTime')" &&
                    !error.message.includes("player.getCurrentTime is not a function")) {
                     console.error("Error updating subtitles:", error);
                }
                document.getElementById('subtitle').textContent = '';
            }
        }

        function convertTxtToSrt(txtContent) {
             const pattern = /\[(\d{1,2}):(\d{2})(?:[.,](\d{1,3}))?\]\s*(.*)/g;
             const matches = [...txtContent.matchAll(pattern)];
             let srtContent = '';
             let lastEndTimeSeconds = -1; // Initialize to allow timestamp 0
             let entryIndex = 1;
             for (let i = 0; i < matches.length; i++) {
                 const [_, minutes, seconds, ms, text] = matches[i];
                 const currentStartTimeSeconds = parseInt(minutes) * 60 + parseInt(seconds) + (ms ? parseInt(ms.padEnd(3, '0')) / 1000 : 0);
                 // Allow identical start time if previous ended exactly there, but not earlier
                 if (currentStartTimeSeconds < lastEndTimeSeconds && i > 0) {
                      console.warn(`Timestamp out of order or overlapping, skipping: ${matches[i][0]}`);
                      continue; // Skip this entry
                 }
                 const startTime = formatSrtTime(currentStartTimeSeconds);
                 let endTimeSeconds;
                 if (i < matches.length - 1) {
                     const [nextFull, nextMin, nextSec, nextMs] = matches[i + 1];
                     const nextStartTimeSeconds = parseInt(nextMin) * 60 + parseInt(nextSec) + (nextMs ? parseInt(nextMs.padEnd(3, '0')) / 1000 : 0);
                     // Ensure next timestamp is strictly greater
                     if (nextStartTimeSeconds > currentStartTimeSeconds) {
                         endTimeSeconds = nextStartTimeSeconds;
                     } else {
                         // If next timestamp is not greater, give a default duration and log warning
                         endTimeSeconds = currentStartTimeSeconds + 2.0; // Default 2 seconds duration
                         console.warn(`Next timestamp ${formatSrtTime(nextStartTimeSeconds)} is not after current ${startTime}, using default duration 2s.`);
                         // Don't automatically skip the *next* entry, let the loop handle it
                     }
                 } else {
                     endTimeSeconds = currentStartTimeSeconds + 5; // Default 5 seconds for the last entry
                 }
                 // Ensure end time is strictly greater than start time
                 if (endTimeSeconds <= currentStartTimeSeconds) {
                      endTimeSeconds = currentStartTimeSeconds + 0.1; // Minimal duration
                 }

                 const endTime = formatSrtTime(endTimeSeconds);
                 srtContent += `${entryIndex}\n${startTime} --> ${endTime}\n${text.trim()}\n\n`;
                 lastEndTimeSeconds = endTimeSeconds; // Update last end time
                 entryIndex++; // Increment valid entry index
             }
             return srtContent.trim();
        }

         function formatSrtTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.round((totalSeconds - Math.floor(totalSeconds)) * 1000);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')},${String(milliseconds).padStart(3, '0')}`;
        }

        function clearSubtitles(isFileUpload = false) {
            subtitles = [];
            originalSubtitleContent = null; // Clear original content
            originalSubtitleFilename = null; // Clear original filename
            subtitleSourceType = null; // Clear source type
            document.getElementById('subtitle').textContent = '';
            if (!isFileUpload) { document.getElementById('subtitleUrl').value = ''; }
            document.getElementById('srtFileName').textContent = 'No file selected'; // Reset status display
            document.getElementById('srtFile').value = null;
            updateEmbeddedUrlDisplay(); // Update embed section (likely hide)
            updateLoadedSubtitleDisplay(); // Hide the loaded subtitle info
            updateBaseSubtitleNameDisplay(); // Hide base name display
        }

        // --- MODIFIED Event Listener for File Input ---
        document.getElementById('srtFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                clearSubtitles(true); // Clear previous state, including original info
                document.getElementById('srtFileName').textContent = `Processing: ${file.name}`; // Show processing status
                document.getElementById('subtitleUrl').value = ''; // Clear URL input

                originalSubtitleFilename = file.name; // Store original filename
                subtitleSourceType = 'local'; // Set source type

                const reader = new FileReader();
                reader.onload = (e) => {
                    originalSubtitleContent = e.target.result; // Store original content FIRST
                    let processedContent = originalSubtitleContent; // Work with a copy
                    const format = detectSubtitleFormat(file.name);

                    try {
                        if (format === 'txt') {
                            processedContent = convertTxtToSrt(processedContent);
                            if (!processedContent) throw new Error("TXT conversion resulted in empty content.");
                        } else if (format !== 'srt') {
                            throw new Error('Unsupported file format. Please use .srt or .txt');
                        }
                        // Now parse the (potentially converted) SRT content
                        parseSRT(processedContent);
                        if (!subtitles.length && processedContent.trim()) {
                            throw new Error("Could not parse any valid subtitle entries from the file.");
                        }
                        // If parsing succeeded, update status display
                        document.getElementById('srtFileName').textContent = 'Loaded from Local';

                    } catch (parseError) {
                        alert(`Error processing file "${file.name}":\n${parseError.message}`);
                        console.error(parseError);
                        clearSubtitles(true); // Clear everything on error
                    } finally {
                        // Explicitly hide embed section when using local file, regardless of success/failure
                        updateEmbeddedUrlDisplay(true);
                        // Update displays (will hide if clearSubtitles was called on error)
                        updateLoadedSubtitleDisplay();
                        updateBaseSubtitleNameDisplay();
                    }
                };
                reader.onerror = (e) => {
                    alert(`Error reading file: ${e.target.error}`);
                    clearSubtitles(true);
                };
                reader.readAsText(file);
            }
        });

        // --- MODIFIED Function to Load Subtitle from URL ---
        function loadSubtitleFromUrl() {
            const url = document.getElementById('subtitleUrl').value.trim();
            if (!url) { alert('Please enter a subtitle URL'); return; }
            try { new URL(url); } catch (_) { alert('Invalid Subtitle URL format.'); return; }
            // Clear previous before starting fetch
            clearSubtitles();
            document.getElementById('subtitleUrl').value = url; // Keep URL in input after clearing
            loadSubtitleFromUrlInternal(url);
        }

        function loadSubtitleFromUrlInternal(url) {
            // State should be clear here from loadSubtitleFromUrl/loadFromUrlParams
            document.getElementById('srtFileName').textContent = `Fetching: ${url.substring(url.lastIndexOf('/') + 1)}`; // Show fetching status
            console.log(`Fetching subtitle from URL: ${url}`);

            originalSubtitleFilename = url; // Store URL as the 'filename'
            subtitleSourceType = 'url'; // Set source type

            fetch(url)
                .then(response => {
                    if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); }
                    // Check content type if possible, though CORS might prevent this
                    // const contentType = response.headers.get("content-type");
                    // console.log("Fetched Content-Type:", contentType);
                    return response.text();
                })
                .then(content => {
                     originalSubtitleContent = content; // Store original content FIRST
                     if (!originalSubtitleContent || originalSubtitleContent.trim() === '') {
                         throw new Error("Fetched content is empty or whitespace only.");
                     }

                    let processedContent = originalSubtitleContent;
                    const format = detectSubtitleFormat(url); // Detect based on URL extension

                    document.getElementById('srtFileName').textContent = 'Loaded from URL'; // Update status display

                    try {
                        if (format === 'txt') {
                            processedContent = convertTxtToSrt(processedContent);
                            if (!processedContent) throw new Error("TXT conversion resulted in empty content.");
                        } else if (format !== 'srt') {
                            // If not .srt or .txt, attempt SRT parse but warn
                            if (format !== null) { // e.g., .vtt, .sub etc.
                                console.warn(`Unsupported URL format extension detected (expected .srt or .txt), attempting to parse as SRT anyway: ${url}`);
                            } else { // No extension or unknown
                                console.warn("Unknown subtitle format from URL (no .srt or .txt extension), attempting to parse as SRT.");
                            }
                            // Continue to parseSRT below
                        }
                        // Parse the (potentially converted or assumed SRT) content
                        parseSRT(processedContent);
                         if (!subtitles.length && processedContent.trim()){
                             throw new Error("Could not parse any valid subtitle entries from the URL content.");
                         }
                        // Update embed URL display now that subtitle URL is confirmed valid & parsed
                        updateEmbeddedUrlDisplay();

                    } catch (parseError) {
                        alert(`Error processing subtitle from URL "${url}":\n${parseError.message}`);
                        console.error(parseError);
                        clearSubtitles(); // Clear everything on error
                    }
                    // Update displays (will hide if clearSubtitles was called on error)
                    updateLoadedSubtitleDisplay();
                    updateBaseSubtitleNameDisplay();
                })
                .catch(error => {
                    alert(`Error fetching or processing subtitle URL:\n${error.message}`);
                    console.error(error);
                    clearSubtitles(); // Clear everything on fetch/process error
                });
        }

        function detectSubtitleFormat(filenameOrUrl) {
            if (!filenameOrUrl) return null;
            const lower = filenameOrUrl.toLowerCase();
            // Get path part before query string
            const path = lower.split('?')[0];
            if (path.endsWith('.srt')) return 'srt';
            if (path.endsWith('.txt')) return 'txt';
            return null; // Unknown or no extension
        }

        // --- NEW Function to Update Loaded Subtitle Info Display ---
        function updateLoadedSubtitleDisplay() {
            const container = document.getElementById('loadedSubtitleInfoContainer');
            const textElement = document.getElementById('loadedSubtitleFilenameText');
            const downloadButton = document.getElementById('downloadSubtitleButton');

            if (originalSubtitleFilename && subtitleSourceType && originalSubtitleContent) {
                const prefix = subtitleSourceType === 'local' ? '[Local] ' : '[URL] ';
                let displayFilename = originalSubtitleFilename;
                if (subtitleSourceType === 'url') {
                    try {
                        // Extract only the filename part after the last '/' and before any '?'
                        const urlParts = displayFilename.split('?')[0].split('/');
                        displayFilename = urlParts[urlParts.length - 1];
                        if (!displayFilename) { // Handle cases like "https://example.com/"
                             displayFilename = originalSubtitleFilename.replace(/^https?:\/\//, ''); // Fallback to URL without protocol
                        }
                    } catch (e) {
                         console.error("Error extracting filename from URL:", e);
                         // Fallback to URL without protocol if parsing fails
                         displayFilename = displayFilename.replace(/^https?:\/\//, '');
                    }
                }
                // Assign potentially modified filename
                textElement.textContent = prefix + displayFilename;
                textElement.title = prefix + originalSubtitleFilename; // Show full original path/URL on hover

                downloadButton.style.display = 'inline-block';
                container.style.display = 'flex'; // Use flex to show container
            } else {
                textElement.textContent = '';
                textElement.title = ''; // Clear title attribute
                downloadButton.style.display = 'none';
                container.style.display = 'none'; // Hide container
            }
        }
        // --- NEW Function to Update Base Subtitle Name Display ---
        function updateBaseSubtitleNameDisplay() {
             const displayElement = document.getElementById('baseSubtitleNameDisplay');
             if (originalSubtitleFilename && subtitleSourceType) {
                 try {
                     let filename = originalSubtitleFilename;
                     // If URL, extract the filename part after the last '/'
                     if (subtitleSourceType === 'url') {
                         const urlParts = filename.split('?')[0].split('/');
                         filename = urlParts[urlParts.length - 1];
                     }
                     // Remove .srt or .txt extension
                     const baseName = filename.replace(/\.(srt|txt)$/i, '');
                     displayElement.textContent = baseName || '[Subtitle Loaded]'; // Fallback text if name is empty after processing
                     displayElement.title = baseName; // Add title for potentially truncated names
                     displayElement.style.display = 'block';
                 } catch (e) {
                     console.error("Error extracting base filename:", e);
                     displayElement.textContent = '[Subtitle Loaded]'; // Fallback
                     displayElement.style.display = 'block';
                 }
             } else {
                 displayElement.textContent = '';
                 displayElement.style.display = 'none';
             }
        }

        // --- NEW Function to Download Original Subtitle ---
        function downloadOriginalSubtitle() {
            if (!originalSubtitleContent || !originalSubtitleFilename) {
                alert("No subtitle content available to download.");
                return;
            }

            try {
                const blob = new Blob([originalSubtitleContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                // Use the original filename for download
                a.download = originalSubtitleFilename.split('/').pop(); // Use only the filename part
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (e) {
                alert("Error creating download link: " + e.message);
                console.error("Download error:", e);
            }
        }


        // --- MODIFIED Function to Update Embedded URL Display ---
        function updateEmbeddedUrlDisplay(isLocalFile = false) {
            const videoUrlInput = document.getElementById('youtubeUrl');
            const subtitleUrlInput = document.getElementById('subtitleUrl'); // Use the input field value
            const container = document.getElementById('embeddedUrlContainer');
            const textarea = document.getElementById('embeddedUrlTextarea');
            const copyButton = document.getElementById('copyUrlButton');

            const videoUrlValue = videoUrlInput.value.trim();
            // Use the value from the input field for subtitle URL, as originalSubtitleFilename might be a local file path
            const subtitleUrlValue = subtitleUrlInput.value.trim();

            // Conditions: Not local file, both URLs present in inputs, valid video ID, subtitle source is URL
            if (!isLocalFile && videoUrlValue && subtitleUrlValue && extractVideoId(videoUrlValue) && subtitleSourceType === 'url') {
                 try {
                    // Basic validation: check if subtitle URL input looks like a URL
                    new URL(subtitleUrlValue);

                    // Construct visually readable URL (NO ENCODING for parameters)
                    // Use the actual values from the input fields for the displayed URL
                    const readableEmbedUrl = `${BASE_EMBED_URL}?videoUrl=${videoUrlValue}&subtitleUrl=${subtitleUrlValue}`;
                    textarea.value = readableEmbedUrl; // Set textarea to readable version

                    container.style.display = 'flex'; // Show container
                    copyButton.disabled = false;
                    console.log("Displaying visually readable embed URL:", readableEmbedUrl);

                 } catch (_) {
                     // Hide if subtitle URL seems invalid
                     container.style.display = 'none';
                     textarea.value = '';
                     copyButton.disabled = true;
                     console.log("Hiding embed URL: Invalid subtitle URL format or other issue.");
                 }
            } else {
                // Hide if conditions not met or local file used
                container.style.display = 'none';
                textarea.value = '';
                copyButton.disabled = true;
                 if (isLocalFile) console.log("Hiding embed URL: Local file is used.");
                 else if (subtitleSourceType !== 'url') console.log("Hiding embed URL: Subtitle source is not URL.");
                 else console.log("Hiding embed URL: Missing Video or Subtitle URL in inputs, or invalid Video ID.");

            }
             resetCopyButtonState(copyButton); // Ensure button state is correct
        }
        // --- End MODIFIED Function ---

        // --- Copy Functionality (Unchanged - Copies textarea content) ---
        function copyUrlToClipboard() {
            const textarea = document.getElementById('embeddedUrlTextarea');
            const copyButton = document.getElementById('copyUrlButton');
            // Construct the *correctly encoded* URL for copying
            const videoUrlValue = document.getElementById('youtubeUrl').value.trim();
            const subtitleUrlValue = document.getElementById('subtitleUrl').value.trim(); // Use input value

             if (!videoUrlValue || !subtitleUrlValue || !navigator.clipboard) {
                 alert("Cannot copy URL. Video or Subtitle URL missing, or Clipboard API not available.");
                 return;
             }

             // Encode parameters properly for the actual URL to be copied
             const encodedVideoUrl = encodeURIComponent(videoUrlValue);
             const encodedSubtitleUrl = encodeURIComponent(subtitleUrlValue);
             const urlToCopy = `${BASE_EMBED_URL}?videoUrl=${encodedVideoUrl}&subtitleUrl=${encodedSubtitleUrl}`;


            navigator.clipboard.writeText(urlToCopy).then(() => {
                console.log('Encoded URL copied to clipboard!', urlToCopy);
                copyButton.textContent = 'Copied!';
                copyButton.classList.add('copied');
                copyButton.disabled = true;
                 clearTimeout(copyTimeout);
                copyTimeout = setTimeout(() => { resetCopyButtonState(copyButton); }, 2000);
            }).catch(err => {
                console.error('Failed to copy URL: ', err);
                alert('Failed to copy URL. Please try copying manually.');
                resetCopyButtonState(copyButton);
            });
        }

        function resetCopyButtonState(button) {
            button.textContent = 'Copy';
            button.classList.remove('copied');
            // Enable copy button only if the embed container is visible
            button.disabled = (document.getElementById('embeddedUrlContainer').style.display === 'none');
        }
        // --- End Copy Functions ---

        // --- Load From URL Params (MODIFIED) ---
        function loadFromUrlParams() {
             const urlParams = new URLSearchParams(window.location.search);
             const videoUrlParam = urlParams.get('videoUrl');
             const subtitleUrlParam = urlParams.get('subtitleUrl');
             let videoIsLoading = false;

              if (videoUrlParam) {
                  const decodedVideoUrl = decodeURIComponent(videoUrlParam);
                  document.getElementById('youtubeUrl').value = decodedVideoUrl;
                  const videoId = extractVideoId(decodedVideoUrl);
                  if (videoId) {
                      videoIsLoading = true; // Flag that video is being loaded now
                      const loadSubtitleAfterVideo = () => {
                           if (subtitleUrlParam) {
                               const decodedSubtitleUrl = decodeURIComponent(subtitleUrlParam);
                               document.getElementById('subtitleUrl').value = decodedSubtitleUrl; // Set input
                               // Do not call clearSubtitles here, loadSubtitleFromUrlInternal assumes clean state
                               loadSubtitleFromUrlInternal(decodedSubtitleUrl); // Load subtitle
                           } else {
                               // No subtitle param, ensure displays are updated/cleared
                               updateEmbeddedUrlDisplay();
                               updateLoadedSubtitleDisplay();
                               updateBaseSubtitleNameDisplay();
                           }
                      };

                      if (!player) {
                          player = new YT.Player('player', {
                              height: '100%', width: '100%', videoId: videoId,
                              playerVars: { 'playsinline': 1 },
                              events: {
                                  'onReady': () => {
                                      onPlayerReady();
                                      loadSubtitleAfterVideo(); // Load subtitle once video is ready
                                  },
                                  'onStateChange': onPlayerStateChange
                              }
                          });
                      } else {
                          player.loadVideoById(videoId);
                          // If player already exists, we can load subtitle immediately
                           loadSubtitleAfterVideo();
                      }
                  } else {
                      console.warn("Invalid videoUrl parameter:", decodedVideoUrl);
                      alert("Invalid video URL in page parameters.");
                      // If video URL is invalid, still try loading subtitle if present
                      videoIsLoading = false;
                  }
              }

              // Load subtitle only if param exists AND video wasn't being initialized above
              // OR if video URL was invalid but subtitle URL is present
              if (subtitleUrlParam && !videoIsLoading) {
                  const decodedSubtitleUrl = decodeURIComponent(subtitleUrlParam);
                  document.getElementById('subtitleUrl').value = decodedSubtitleUrl; // Set input
                  // Clear any potential previous state before loading
                  clearSubtitles();
                  loadSubtitleFromUrlInternal(decodedSubtitleUrl); // Load subtitle
              }

             // Final check to ensure display is updated if no valid params were processed
             // Or if only video was loaded without subtitle param
             if (!videoUrlParam && !subtitleUrlParam) {
                 updateEmbeddedUrlDisplay();
                 updateLoadedSubtitleDisplay();
                 updateBaseSubtitleNameDisplay();
             } else if (videoUrlParam && !subtitleUrlParam && !videoIsLoading) {
                 // Case where video param was valid, player existed, but no subtitle param
                 updateEmbeddedUrlDisplay();
                 updateLoadedSubtitleDisplay();
                 updateBaseSubtitleNameDisplay();
             }
        }
        // --- End Load From URL Params ---


        // Add event listener for the copy button and initialize displays
         document.addEventListener('DOMContentLoaded', () => {
             const copyButton = document.getElementById('copyUrlButton');
             if (copyButton) {
                 copyButton.addEventListener('click', copyUrlToClipboard);
             }
             // Initial display state setup (should be hidden by default)
             updateLoadedSubtitleDisplay();
             updateBaseSubtitleNameDisplay();
             updateEmbeddedUrlDisplay(); // Check initial state for embed URL visibility

             // YouTube API is loaded asynchronously, call loadFromUrlParams there.
             // If API is already loaded (e.g., navigating back), trigger manually?
             // The onYouTubeIframeAPIReady handles the initial load, so this might be redundant.
             // However, if the API loads *before* DOMContentLoaded, this ensures params are checked.
             // if (typeof YT !== 'undefined' && YT.Player) {
             //      loadFromUrlParams();
             // }
         });
function generateAndCopyLink() {
    // 1. Get the current values from the input boxes
    const videoUrl = document.getElementById('youtubeUrl').value.trim();
    const subtitleUrl = document.getElementById('subtitleUrl').value.trim();

    // 2. Validation: Ensure at least a video is present
    if (!videoUrl) {
        alert("Please enter a YouTube URL first.");
        return;
    }

    // 3. Get the current page's address (The Client's location)
    // This grabs "https://github.com/.../script_test2.html" automatically
    const baseUrl = window.location.href.split('?')[0];

    // 4. Construct the parameters
    // We use encodeURIComponent to ensure symbols like '?' and '&' inside the 
    // video link don't confuse the browser.
    let newUrl = `${baseUrl}?videoUrl=${encodeURIComponent(videoUrl)}`;
    
    if (subtitleUrl) {
        newUrl += `&subtitleUrl=${encodeURIComponent(subtitleUrl)}`;
    }

    // 5. Copy to Clipboard
    // This uses the Client's system API to write to the clipboard
    navigator.clipboard.writeText(newUrl).then(() => {
        alert("Link copied to clipboard!\n\nYou can now share this URL.");
    }).catch(err => {
        console.error('Failed to copy: ', err);
        // Fallback if clipboard fails: show the link in a prompt
        prompt("Copy this link manually:", newUrl);
    });
}
    </script>
</body>
</html>
