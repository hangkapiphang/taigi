<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Siong Taigi (Class Recorder)</title>
    <style>
        /* --- FONTS --- */
        @font-face { font-family: 'Taigi Font'; src: url('./font/Charis-Regular.woff2') format('woff2'); font-weight: normal; font-style: normal; }
        @font-face { font-family: 'Taigi Font'; src: url('./font/Charis-Bold.woff2') format('woff2'); font-weight: bold; font-style: normal; }

        body { margin: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: Arial, sans-serif; }
        
        #video-container { 
            position: relative; width: 100%; height: 100%; 
            max-width: 177.78vh; max-height: 56.25vw; 
            margin: auto; background-color: #000; 
        }
        #player { width: 100%; height: 100%; border: none; }
        
        #mask-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background-color: #000; z-index: 50; pointer-events: none; transition: all 0.5s ease; }
        
        #subtitle { position: absolute; top: 5%; left: 50%; transform: translateX(-50%); width: 98%; text-align: center; pointer-events: none; z-index: 100; }
        
        #subtitle span { 
            background-color: rgba(0, 0, 0, 0.4); color: #fff; font-family: 'Taigi Font', serif; 
            font-size: clamp(32px, 3vw, 55px); line-height: 1.6; padding: 4px 8px; 
            box-decoration-break: clone; -webkit-box-decoration-break: clone; border-radius: 6px; 
            text-shadow: 2px 2px 3px #444; 
        }
        #subtitle span b { color: #fff; text-shadow: 0 0 2px #ccc; }

        @media screen and (max-width: 768px) { #subtitle span { font-size: clamp(24px, 6vw, 40px); padding: 2px 6px; line-height: 1.5; } }

        /* --- RECORDING UI --- */
        #rec-panel {
            position: fixed;
            top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 9999;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            text-align: center;
            width: 220px;
            transition: opacity 0.3s;
        }
        /* Hide UI when recording so it doesn't block view */
        body.recording #rec-panel { opacity: 0.1; }
        body.recording #rec-panel:hover { opacity: 1; }

        #rec-btn {
            background-color: #dc3545; color: white; border: none;
            padding: 10px 20px; font-size: 16px; border-radius: 5px;
            cursor: pointer; width: 100%; font-weight: bold;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        #rec-btn.recording { background-color: #333; animation: pulse 2s infinite; }
        
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); } 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); } }

        #status { font-size: 12px; margin-top: 8px; color: #333; }
        .inst { font-size: 11px; text-align: left; color: #555; margin-top: 8px; border-top: 1px solid #ccc; padding-top: 5px; }
    </style>
</head>
<body>

    <!-- RECORDING INTERFACE -->
    <div id="rec-panel">
        <button id="rec-btn" onclick="toggleRecord()">
            <div style="width:12px; height:12px; background:white; border-radius:50%;"></div>
            Start Record
        </button>
        <div id="status">Ready</div>
        <div class="inst">
            <strong>Instructions:</strong><br>
            1. Click Start.<br>
            2. Choose <b>"This Tab"</b>.<br>
            3. Enable <b>"Share Audio"</b>.<br>
            4. Play video.<br>
            5. Click Stop to save (.webm).
        </div>
    </div>

    <div id="video-container">
        <div id="mask-bar"></div>
        <div id="player"></div>
        <div id="subtitle"><span></span></div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        let player; 
        let subtitles = [];
        let mediaRecorder;
        let recordedChunks = [];

        // --- RECORDING LOGIC ---
        async function toggleRecord() {
            const btn = document.getElementById('rec-btn');
            const status = document.getElementById('status');

            if (btn.classList.contains('recording')) {
                // STOP RECORDING
                mediaRecorder.stop();
                btn.classList.remove('recording');
                btn.innerHTML = '<div style="width:12px; height:12px; background:white; border-radius:50%;"></div> Start Record';
                status.textContent = "Processing...";
                document.body.classList.remove('recording');
            } else {
                // START RECORDING
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({
                        video: { 
                            displaySurface: "browser", 
                            preferCurrentTab: true 
                        },
                        audio: true, // Captures video sound
                        selfBrowserSurface: "include" 
                    });

                    const mimeType = MediaRecorder.isTypeSupported("video/webm;codecs=vp9") 
                        ? "video/webm;codecs=vp9" 
                        : "video/webm";

                    mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                    recordedChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) recordedChunks.push(event.data);
                    };

                    mediaRecorder.onstop = saveRecording;

                    mediaRecorder.start();
                    btn.classList.add('recording');
                    btn.innerHTML = '⬛ Stop Recording';
                    status.textContent = "Recording... (Play Video)";
                    document.body.classList.add('recording');

                    stream.getVideoTracks()[0].onended = () => {
                        if (btn.classList.contains('recording')) toggleRecord();
                    };

                } catch (err) {
                    console.error("Error: " + err);
                    alert("Recording cancelled.");
                }
            }
        }

        function saveRecording() {
            const blob = new Blob(recordedChunks, { type: "video/webm" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            document.body.appendChild(a);
            a.style = "display: none";
            a.href = url;
            a.download = "siong_taigi_lesson.webm"; 
            a.click();
            window.URL.revokeObjectURL(url);
            document.getElementById('status').textContent = "Saved to Downloads!";
        }

        // --- STANDARD CINEMA LOGIC ---
        function onYouTubeIframeAPIReady() {
            const movieId = new URLSearchParams(window.location.search).get('id');
            if (movieId) {
                fetch(`data/${movieId}.json?t=${new Date().getTime()}`)
                    .then(r => r.json())
                    .then(data => {
                        // 1. Video
                        if (data.video) createPlayer(extractVideoId(data.video));
                        
                        // 2. Subtitles
                        if (data.subtitle) parseSRT(data.subtitle);
                        else if (data.hiddenSub) parseSRT(decryptSubtitle(data.hiddenSub)); 
                        
                        // 3. Mask
                        const m = document.getElementById('mask-bar');
                        if (data.mask) { 
                            m.style.height = data.mask.h + "%"; 
                            m.style.width = data.mask.w + "%"; 
                            m.style.bottom = data.mask.b + "%"; 
                            m.style.left = data.mask.l + "%"; 
                            if(data.mask.c) m.style.backgroundColor = data.mask.c;
                            if(data.mask.o) m.style.opacity = data.mask.o;
                        }
                        
                        // 4. Appearance
                        if (data.settings || data.subtitlePos) {
                            const set = data.settings || data.subtitlePos;
                            const sub = document.getElementById('subtitle');
                            const span = document.querySelector('#subtitle span');
                            
                            if (set.anchor) {
                                sub.style.top = 'auto'; sub.style.bottom = 'auto';
                                if (set.anchor === 'top') sub.style.top = set.offset + "%"; else sub.style.bottom = set.offset + "%";
                            }
                            if (set.scale) applyFontScale(set.scale);
                            if (set.color) span.style.color = set.color;
                            
                            if (set.boxColor && set.boxOp !== undefined) {
                                const rgb = hexToRgb(set.boxColor);
                                span.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${set.boxOp})`;
                            }
                            
                            if (set.shadow !== undefined) {
                                const s = set.shadow;
                                const shadowCol = set.shadowColor || "#000000"; 
                                if (s == 0) span.style.textShadow = "none";
                                else span.style.textShadow = `${s}px ${s}px ${s}px ${shadowCol}`;
                            }
                        }
                    })
                    .catch(e => console.error(e));
            }
        }
        
        function applyFontScale(ratio) {
            const pc = `clamp(${32*ratio}px, ${3*ratio}vw, ${55*ratio}px)`;
            const mob = `clamp(${24*ratio}px, ${6*ratio}vw, ${40*ratio}px)`;
            const style = document.createElement('style');
            style.innerHTML = `#subtitle span { font-size: ${pc} !important; } @media screen and (max-width: 768px) { #subtitle span { font-size: ${mob} !important; } }`;
            document.head.appendChild(style);
        }

        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        function createPlayer(id) {
            player = new YT.Player('player', { videoId: id, playerVars: { 'autoplay': 1, 'playsinline': 1, 'controls': 1, 'rel': 0, 'start': 0, 'fs': 0, 'cc_load_policy': 0, 'iv_load_policy': 3 }, events: { 'onReady': onPlayerReady } });
        }
        function onPlayerReady(event) { event.target.seekTo(0); event.target.playVideo(); setInterval(updateSubtitles, 100); try{ player.unloadModule("captions"); }catch(e){} }
        function updateSubtitles() {
            if (!player || typeof player.getCurrentTime !== 'function') return;
            const ct = player.getCurrentTime();
            const sub = subtitles.find(s => ct >= s.start && ct <= s.end);
            const span = document.querySelector('#subtitle span');
            if (sub) { span.innerHTML = sub.text; span.style.display = 'inline'; } else { span.innerHTML = ''; span.style.display = 'none'; }
        }
        function decryptSubtitle(scrambled) { try { return decodeURIComponent(escape(atob(atob(scrambled).split('').reverse().join('')))); } catch (e) { return ""; } }
        function parseSRT(srt) {
            subtitles = [];
            srt.trim().split(/\n\s*\n/).forEach(block => {
                const lines = block.split('\n');
                if (lines.length >= 3) {
                    const m = lines[1].match(/(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})/);
                    if (m) subtitles.push({ start: timeToSeconds(m[1]), end: timeToSeconds(m[2]), text: lines.slice(2).join('<br>').replace(/-/g, '‑') });
                }
            });
        }
        function timeToSeconds(t) { const [h, m, s] = t.replace(',', '.').split(':'); return parseInt(h)*3600 + parseInt(m)*60 + parseFloat(s); }
        function extractVideoId(url) { const m = url.match(/[?&]v=([^&#]*)/) || url.match(/youtu\.be\/([^?&#]+)/); return m && m[1] ? m[1] : null; }
    </script>
</body>
</html>